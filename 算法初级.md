# 1 认识时间复杂度

## 1.3 对数器

当设计好一个程序并且用代码实现后，如何在大样本的情况下对设计的程序代码进行雁阵，此时就要用到对数器。

对数器的实现步骤 ：

* 有一个想要测试的方法A（自己实现的算法）
* 实现一个绝对正确但是复杂度不好的方法B
* 实现一个随机样本产生器
* 实现对比A和B的方法
* 把方法A和方法B比对很多次来验证方法A是否正确
* 如果有一个样本是的对比出错，打印样本分析是哪个方法出错
* 当样本数量很多时比对测试依然正确，可以确定方法A已经正确

# 2 排序算法

## 2.1 冒泡排序

### 2.1.1 算法描述

> 对于一个无序数组，比如数组`A[3,2,4,0,7]`，按顺序，数组的中的相邻的两个数两两比较，前一个数比后一个数大交换(升序)，知道数组中的最后一个元素，此时数组中的最大的元素到数组的最后一个位置，那么该数就排好了序；
>
> 对于剩下的元素反复执行上面的过程，每次让最大的数到数组的后面，直到A数组中的六个元素都排好序为止。冒泡排序的示意图如下：

![image-20200319200816199](C:\Users\Dabric\AppData\Roaming\Typora\typora-user-images\image-20200319200816199.png)

冒泡排序算法的时间复杂度**O(N^2)**，额外空间复杂度**O(1)**。

### 2.1.2 代码实现

```go
func BubbleSort(slice []int) {
    for i := len(slice) - 1; i > 0; i-- { //控制轮数
        for j := 0; j < i; j++ {  //控制每一轮比较的次数
            if slice[j] > slice[j+1] {
                swap(slice, j, j+1)
            }
        }
    }
}

func swap(slice []int, x, y int) {
    slice[x] = slice[x] ^ slice[y]
    slice[y] = slice[x] ^ slice[y]
    slice[x] = slice[x] ^ slice[y]
}
```

### 2.1.3 实现对数器

```go
func comparator(slice []int) {
	// 比较器，绝对正确的方法
	sort.Ints(slice)
}

func generateRandomArray(maxSize, maxValue int) (slice []int) {  // 生成随机长度随机元素的切片
	for i := 0; i < rand.Intn(maxSize+1); i++ {
		slice = append(slice, rand.Intn(maxValue+1) - rand.Intn(maxValue))
	}
	return
}

func copyArray(slice []int) []int {
	if slice == nil {
		return nil
	}
	var res []int
	for i := 0; i < len(slice); i++ {
		res = append(res, slice[i])
	}
	return res
}

// 判断两个切片是否相等
func isEqual(slice1, slice2 []int) bool {
	if (slice1 == nil && slice2 != nil) || (slice1 != nil && slice2 == nil) {
		return false
	}

	if slice1 == nil && slice2 == nil {
		return true
	}
	if len(slice1) != len(slice2) {
		return false
	}
	for i := 0; i < len(slice1); i++ {
		if slice1[i] != slice2[i] {
			return false
		}
	}
	return true
}

func main() {
	rand.Seed(time.Now().UnixNano())
	var testTime int = 500000
	var maxSize = 100
	var maxValue = 100
	var succeed = true

	for i := 0; i < testTime; i++ {
		slice1 := generateRandomArray(maxSize, maxValue)
		slice2 := copyArray(slice1)
		BubbleSort(slice1)
		comparator(slice2)
		fmt.Println(slice1)
		fmt.Println(slice2)
		if !isEqual(slice1, slice2){
			succeed = false
			break
		}
	}
	if succeed {
		fmt.Println("Nice!")
	} else {
		fmt.Println("Fucking fucked!")
	}
}
```



## 2.2 选择排序

### 2.2.1 算法描述

> 对于一个无序数组，假设数组中第一个位置上的数为最小的数，然后遍历数组中其他位置上的数，看是否有比第一个位置上的数更小的数，如果有则交换两个位置上的数，当数组遍历完，也就找到数组中最小的数；
>
> 之后假定第二个位置上的数为最小数，重复上面的过程；
>
> 依次重复之前的过程，直到整个数据排完序。选择排序示意图如下：

![image-20200319235032570](C:\Users\Dabric\AppData\Roaming\Typora\typora-user-images\image-20200319235032570.png)

时间复杂度**O(N^2)**，额外空间复杂度**O(1)**。

### 2.2.2 代码实现

```go
func selectionSort(slice []int) {
	for i := 0; i < len(slice); i++ {
		minIndex := i
		for j := i + 1; j < len(slice); j++ {
			if slice[minIndex] > slice[j] {
				swap(slice, minIndex, j)
			}
		}
	}
}

func swap(slice []int, x, y int) {
	slice[x] = slice[x] ^ slice[y]
	slice[y] = slice[x] ^ slice[y]
	slice[x] = slice[x] ^ slice[y]
}
```

## 2.3插入排序

### 2.3.1 算法描述

> 插入排序的算法流程就像是打扑克在接牌的时候，每次来一张新牌时，将其按顺序插入到指定的位置上。假设有一个无序数组`A[5,3,4,0,6]`，起初，假设0-0位置上已经排好序，遍历数组，将每个数插入到其适当的位置。插入排序的示意图如下：

![image-20200320003336373](C:\Users\Dabric\AppData\Roaming\Typora\typora-user-images\image-20200320003336373.png)

插入排序时间复杂度**O(N^2)**，额外空间复杂度**O(1)**。

### 2.3.2 代码实现

```go
func insertionSort(slice []int) {
	for i := 1; i < len(slice); i++ {
		for j := i - 1; j >= 0 && slice[j] > slice[j+1]; j-- {
			swap(slice, j, j+1)
		}
	}
}

func swap(slice []int, x, y int) {
	slice[x] = slice[x] ^ slice[y]
	slice[y] = slice[x] ^ slice[y]
	slice[x] = slice[x] ^ slice[y]
}
```

## 2.4归并排序

### 2.4.1 归并算法描述

> 算法描述：
>
> 对于一个无序数组`A[5,3,4,0,6,1]`，分别对左半边部分和右半边部分进行排序，得到左:`[3,4,5]`和右:`[0,1,6]`；最后使用外排的方式，将两部分的进行排序。
>
> 外排merge过程描述：
>
> 辅助数组`help[]`，长度等于A数组的长度，a指向左部分的第一个数，b指向右部分的第一个数；
>
> 比较a和b位置上的数，指定位置上的数谁小填入到辅助数组中，并且指针右移；
>
> 当其中一个指针移除各自的边界，将另外一部分剩下的数copy到辅助数组中；
>
> 最后将辅助数组中的数copy到原数组A中。

递归实现归并的merge过程示意图：

![image-20200320211334392](C:\Users\Dabric\AppData\Roaming\Typora\typora-user-images\image-20200320211334392.png)

### 2.4.2 代码实现

```go
package main

import "fmt"

func mergeSort(slice []int, L, R int) {
	if L == R {
		return
	}
	mid := L + (R - L) >> 1
	mergeSort(slice, L, mid)
	mergeSort(slice, mid+1, R)
	merge(slice, L, R, mid)
}

func merge(slice []int, L, R, mid int) {
	var help []int = make([]int, R-L+1)
	i := 0
	p1 := L
	p2 := mid+1
	for p1 <= mid && p2 <= R {
		if slice[p1] < slice[p2] {
			help[i] = slice[p1]
			p1++
		} else {
			help[i] = slice[p2]
			p2++
		}
		i++
	}

	for p1 <= mid {
		help[i] = slice[p1]
		i++
		p1++
	}

	for p2 <= R {
		help[i] = slice[p2]
		i++
		p2++
	}

	for j := 0; j < len(help); j++ {
		slice[L+j] = help[j]
	}
}
```

### 2.4.3 归并排序的应用

> 小和问题和逆序对问题
> 小和问题
> 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组
> 的小和。
> 例子：
> [1,3,4,2,5]
> 1左边比1小的数，没有；
> 3左边比3小的数，1；
> 4左边比4小的数，1、3；
> 2左边比2小的数，1；
> 5左边比5小的数，1、3、4、2；
> 所以小和为1+1+3+1+1+3+4+2=16
>
> 在merge的过程中产生小和，左右排序中也产生小和



代码实现：

```go
package main

import "fmt"

func smallSum(slice []int, L, R int) (res int) {
	if L == R {
		return 0
	}
	mid := L + (R - L) >> 1
	return smallSum(slice, L, mid) + smallSum(slice, mid + 1, R) + merge(slice, L, mid, R)
}

func merge(slice []int, L, mid, R int) (res int) {
	var help []int = make([]int, R-L+1)
	i := 0
	p1 := L
	p2 := mid + 1
	for p1 <= mid && p2 <= R {

		if slice[p1] < slice[p2] {
			// 产生小和，并且，p1小于(p2, R]上的数，于是产生的小和为p1 *(R-p2+1)
			res = res + slice[p1] *(R-p2+1)
		} else {
			res += 0
		}

		if slice[p1] < slice[p2] {
			help[i] = slice[p1]
			p1++
		} else {
			help[i] = slice[p2]
			p2++
		}
		i++
	}

	for p1 <= mid {
		help[i] = slice[p1]
		i++
		p1++
	}

	for p2 <= R {
		help[i] = slice[p2]
		i++
		p2++
	}

	for j := 0; j < len(help); j++ {
		slice[L+j] = help[j]
	}
	return
}
```

> 逆序对问题
> 在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序
> 对。
>
> merge的过程中产生逆序对，左排好右排也产生逆序对

```go
package main

import "fmt"

func reverseAligment(slice []int, L, R int) (res [][2]int) {
	if L == R {
		return nil
	}
	mid := L + (R - L) >> 1
	res1 := reverseAligment(slice, L, mid)
	res2 := reverseAligment(slice, mid+1, R)
	res3 := merge(slice, L, mid, R)
	res = append(res, res1...)
	res = append(res, res2...)
	res = append(res, res3...)
	return
}

func merge(slice []int, L, mid, R int) (res [][2]int) {
	var help []int = make([]int, R-L+1)
	i := 0
	p1 := L
	p2 := mid + 1

	for p1 <= mid && p2 <= R {
		// merge的过程产生逆序对，并且，如果p1上的数大于p2指定的数，那么(p1, mid]上的数都大于p2指定的数
		if slice[p1] > slice[p2] {
			var r [2]int
			for index := p1; index <= mid; index++ {
				r[0] = slice[index]
				r[1] = slice[p2]
				res = append(res, r)
			}
		}
		if slice[p1] <= slice[p2] {
			help[i] = slice[p1]
			p1++
		} else {
			help[i] = slice[p2]
			p2++
		}
		i++
	}

	for p1 <= mid {
		help[i] = slice[p1]
		p1++
		i++
	}

	for p2 <= R {
		help[i] = slice[p2]
		p2++
		i++
	}

	for j := 0; j < len(help); j++ {
		slice[L+j] = help[j]
	}
	return
}

func main() {
	s := []int{5,4,3,2,1}
	res := reverseAligment(s, 0, 4)
	fmt.Println(res)
}
```

## 2.5 快速排序

### 2.5.1 荷兰国旗问题

> 给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。
>
> 要求额外空间复杂度O(1)，时间复杂度O(N)

算法描述：

> 对于无序数组`A[4,6,5,3,5,8]`，给定`num=5`。
>
> 首先小于区域less指针指向-1表示此时的小于区域不存在；
>
> 大于区域more指针指向`len(A)`表示此时的大于区域不存在；
>
> 遍历数组中的数：
>
> cur指向的数如果小于num，则和小于区域的下一个数交换，小于区域扩大，less++，cur++；
>
> cur指向的数如果等于num，cur++；
>
> cur指向的数如果大于num，则和大于区域的前一个数交换，大于 区域扩大，more++；
>
> 重复上述过程，直到cur == more，循环结束。
>
> 该算法过程示意图如下：

![image-20200321220537384](C:\Users\Dabric\AppData\Roaming\Typora\typora-user-images\image-20200321220537384.png)

代码实现：

```go
func partition(slice []int, L, R, num int) [2]int {
	less := -1
	more := R + 1

	cur := 0
	for cur < more {
		if slice[cur] < num {
			swap(slice, cur, less+1)
			less++
			cur++
		} else if slice[cur] > num {
			swap(slice, cur, more-1)
			more--
		} else {
			cur++
		}
	}
	return [2]int{less+1, more-1}
}

func swap(slice []int, x, y int) {
	slice[x] = slice[x] ^ slice[y]
	slice[y] = slice[x] ^ slice[y]
	slice[x] = slice[x] ^ slice[y]
}
```

### 2.5.2 经典快排

算法描述：

> 快排算法是在荷兰国旗的基础上进行的。
>
> 经典快排，将数组中的最后一个数作为num，然后对数组partition，此时数组被划分成三部分：`<num, =num, >num`；
>
> 分别对`<num, >num`这两个区域做patition，重复此过程，直到`L>=R`结束

代码实现：

```go
func quickSort(slice []int) {
	if len(slice) < 2 {
		return
	}
	quickSort_recur(slice, 0, len(slice)-1)
}

func quickSort_recur(slice []int, L, R int) {
	if L < R {
		p := partition(slice, L, R)
		quickSort_recur(slice, L, p[0]-1)
		quickSort_recur(slice, p[1]+1, R)
	}
}


func partition(slice []int, L, R int) (p *[2]int) {
	less := L - 1
	more := R + 1
	cur := L
	for cur < more {
		if slice[cur] < slice[R] {
			swap(slice, cur, less+1)
			cur += 1
			less += 1
		} else if slice[cur] > slice[R] {
			swap(slice, cur, more-1)
			more -= 1
		} else {
			cur += 1
		}
	}
	return &[2]int{less+1, more-1}
}

func swap(slice []int, x, y int) {
	slice[x], slice[y] = slice[y], slice[x]
}
```

> 经典快排存在的问题：
>
> 经典快排每次将最后一个数进行划分，其时间复杂度随着数据样本的变化而变化。
>
> 如果数组为`A[1,2,3,4,5,6,7]`那么其时间复杂度为**O(N^2)**；
>
> 如果划分值num为正中间位置，则左右规模相同，套用master公式，则时间复杂度为**O(NlogN)**。
>
> 于是有了下面的随机快排，其时间复杂度是个概率事件，是一个长期期望的复杂度。
>
> 时间复杂度为**O(NlogN)**，空间复杂度为**O(logN)**。空间浪费在划分点上。
>
> 一个数据样本想避开原始的数据状况，可以使用随机或哈希来规避。

### 2.5.3 随机快排

> 每次partition时，在数组中随机找一个值作为划分点

代码实现：

```go
package main

import (
	"fmt"
	"math/rand"
)

func quickSort(slice []int) {
	if len(slice) < 2 {
		return
	}
	quickSort_recur(slice, 0, len(slice)-1)
}

func quickSort_recur(slice []int, L, R int) {
	if L < R {
		swap(slice, L + rand.Intn(R-L+1), R)
		p := partition(slice, L, R)
		quickSort_recur(slice, L, p[0]-1)
		quickSort_recur(slice, p[1]+1, R)
	}
}

func partition(slice []int, L, R int) (p *[2]int) {
	less := L - 1
	more := R
	for L < more {
		if slice[L] < slice[R] {
			swap(slice, L, less+1)
			L += 1
			less += 1
		} else if slice[L] > slice[R] {
			swap(slice, L, more-1)
			more -= 1
		} else {
			L += 1
		}
	}
	swap(slice, more, R)
	return &[2]int{less+1, more-1}
}

func swap(slice []int, x, y int) {
	slice[x], slice[y] = slice[y], slice[x]
}
```

## 2.6 堆排序

堆的数据结构就是一个完全二叉树。

### 2.6.1 完全二叉树满二叉树



**二叉树**是一个非线性结构的数据结构，它的含义是每个节点最多有两个子节点，二叉树的形式如下：

![image-20200322002009936](C:\Users\Dabric\AppData\Roaming\Typora\typora-user-images\image-20200322002009936.png)

**满二叉树**是最后一层是叶节点，非叶节点的两个孩子都全。如下所示：

![image-20200322002139254](C:\Users\Dabric\AppData\Roaming\Typora\typora-user-images\image-20200322002139254.png)

**非满二叉树**从左向右依次补齐形成的树为**完全二叉树**。如下所示：

![image-20200322002242802](C:\Users\Dabric\AppData\Roaming\Typora\typora-user-images\image-20200322002242802.png)

> 二叉树具有的性质：对于一个节点i，
>
> 其左孩子下标`left = 2i+1`，
>
> 右孩子下标`right = 2i+2`，
>
> 父节点的下标`((i-1)/2)`。

### 2.6.2 形成大根堆

堆分为大根堆和小根堆。大根堆是在完全二叉树的基础上，任何一个子树的最大值为子树的头部，相反的为小根堆。大根堆如下所示：

![image-20200322002858406](C:\Users\Dabric\AppData\Roaming\Typora\typora-user-images\image-20200322002858406.png)

形成大根堆`heapInsert`的算法描述：

> 一个数组，在物理内存上是连续的，在逻辑上可以将其脑补成一个完全二叉树。
>
> 形成大根堆是在一个大根堆的基础上新添加一个节点向上调整的过程。
>
> 判断新添加的节点是否大于其父节点，如果大于则交换；
>
> 继续和上一个父节点比较，直到到根节点为止。
>
> 一个数组形成一个大根堆的示意图如下：

![image-20200322011022108](C:\Users\Dabric\AppData\Roaming\Typora\typora-user-images\image-20200322011022108.png)

代码实现：

```go
func heapInsert(slice []int, index int) {

	for slice[index] > slice[(index-1)/2] {
		swap(slice, index, (index-1)/2)
		index = (index-1)/2     // 调整节点，继续往上比较
	}
}


func swap(slice []int, x, y int) {
	slice[x], slice[y] = slice[y], slice[x]
}
```

调整大根堆`heapify`算法描述：

> 当一个大根堆中的根节点变小时，往下调整，重新生成大根堆
>
> 大根堆有一个长度`heapSize`
>
> 当根节点的数变小时，其孩子节点当中比较出相对较大的节点和父节点交换；
>
> 一直往下执行，直到孩子节点大于`heapSize`为止

代码实现：

```go
func heapify(slice []int, index, heapSize int)  {
	left := index * 2 + 1
	var largest int
	for left < heapSize {
		// 两个孩子之间比较出谁大谁小
		if left + 1 < heapSize && slice[left] < slice[left+1] {
			largest = left + 1
		} else {
			largest = left
		}

		if slice[index] > slice[largest] {
			largest = index
		} else {
			largest = largest
		}

		if largest == index {  // 当前位置的值变小后和左右孩子比较后，还是自身的值大时，此时该值不用下沉；你和你孩子的最大值是自己，直接break
			break
		}
		swap(slice, largest, index)
		index = largest        // 下沉
		left = index * 2 + 1
	}
}
```

### 2.6.4 堆排序

> 1. 数组形成大根堆
> 2. 堆顶和堆最后一个数交换
> 3. 堆的大小减一
> 4. 剩下的范围进行从0开始的heapify，重新调成为大根堆
> 5. 循环执行2、3、4步骤，直到堆的大小小于0结束

代码实现：

```go
func heapSort(slice []int) {
	for k, _ := range slice {
		heapInsert(slice, k)
	}

	heapSize := len(slice)

	swap(slice,0, heapSize-1)
	heapSize--

	for heapSize > 0 {
		heapify(slice, 0, heapSize)
		swap(slice,0, heapSize-1)
		heapSize--
	}
}
```

# 3 排序算法稳定性及其汇总

## 3.1 排序算法的稳定性

排序算法的稳定性是对于一个无序的集合进行排序后，保证原先集合中相同元素的顺序不变，就认为该排序算法稳定。

其意义在于，工程上的业务有时需要保留集合中的原始信息。例如下表中的一些信息：

| username | grade | score |
| :------: | :---: | :---: |
|   张三   |   2   |  17   |
|   李四   |   1   |  20   |
|   王五   |   1   |  60   |

对于一个学生用户，其属性有`grade, score`。首先对学生用户的`score`进行排序，那么学生的成绩从低到高依次排列；随后对学生的`grade`进行排序，如果该排序算法具有稳定性，那么在对`grade`排序后就能够保证同一个班级中的学生的成绩也是按从低到高的次序排列着。所以说，排序的稳定性能够保留原始集合中的一些信息。

## 3.2 排序算法汇总

| 排序算法      | 时间复杂度 | 额外空间复杂度 | 稳定性 |
| ------------- | ---------- | -------------- | ------ |
| BubbleSort    | O(N^2)     | O(1)           | 是     |
| SelectionSort | O(N^2)     | O(1)           | 是     |
| InsertSort    | O(N^2)     | O(1)           | 否     |
| MergeSort     | O(NlogN)   | O(N)           | 是     |
| QuickSort     | O(NlogN)   | O(logN)        | 否     |
| HeapSort      | O(NlogN)   | O(1)           | 否     |

## 3.3 工程中的综合排序算法

工程中的排序算法会根据不同的数据规模使用不同的排序算法，使用的规则大概如下：

> 如果数据规模很大，并且数据都是基础类型(`int, float, int32...`)，使用快排；
>
> 如果数据规模很小（len<60），不管任何数据类型，使用插排。
>
> 尽管插排的时间复杂度为O(N^2)，但是插排的常数项很低，在小样本中的排序很快。

## 3.4 排序问题补充

* 归并排序的额外空间复杂度可以变成O(1)，但是非常难，不需要掌握。可以搜索相关“归并排序，内部缓存法”；

* 快速排序可以做到稳定性问题，但是非常难，不需要掌握。可以搜索“01 stable sort”；

  > 有一道题目，是奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变。
  >
  > 一个整数的集合中的数要么是奇数，要么是偶数，这可以类比到快排上，相当于01组和。快排不具有稳定性，所以此题也做不到稳定性，但是非要做到稳定就需要论文级别的解决方法（01 stable sort）。

# 4 比较器

在Golang中如何根据`struct`中不同的字段，对`struct`的实例进行排序。先看如下代码：

```go
package main

import "sort"

type student struct {
	id   int
	name string
	age  int
}

func main() {
	stu1 := student{
		id:   0,
		name: "tom",
		age:  18,
	}
	stu2 := student{2,"jerry",16}
	stu3 := student{1, "mary", 20}
	students := []student{stu1, stu2, stu3}
	// 使用内建的sort对三个学生实例进行排序
	sort.Sort(students)   // 此时发现不能使用sort.Sort对students类型进行排序，因为students没有实现Interface这个接口类型
}
```

> 使用sort包中的Sort方法对包含student实例的切片排序时，发现不能排序，因为students这个类型没有实现Interface这个接口类型。对代码修改如下：

```go
package main

import (
	"fmt"
	"sort"
)

type student struct {
	id   int
	name string
	age  int
}

type students []student

func (s students) Len() int {
	return len(s)
}

func (s students) Less(i, j int) bool {
	return s[i].age < s[j].age   // 按学生的年龄从小到大排序
}

func (s students) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

func main() {
	stu1 := student{
		id:   0,
		name: "tom",
		age:  18,
	}
	stu2 := student{2,"jerry",16}
	stu3 := student{1, "mary", 20}
	s := students{stu1, stu2, stu3}
	// 使用内建的sort对三个学生实例进行排序
	sort.Sort(s) 
	fmt.Println(s)   // [{2 jerry 16} {0 tom 18} {1 mary 20}]
}
```

> 使用上面的方法有一个弊端，如果下次要按照学生的id进行排序，又要构建一个新的类型，实现Interface这个结构。在对student这个结构体的不同字段进行排序时，只要实现不同的Less方法即可，可以将Less方法抽象出来，让Less方法动态的执行。

```go
package main

import (
	"fmt"
	"sort"
)

type student struct {
	id   int
	name string
	age  int
}

type studentWrapper struct {
	students []student
	comparator func (i,j *student) bool
}


func (s studentWrapper) Len() int {
	return len(s.students)
}

func (s studentWrapper) Less(i, j int) bool {
	return s.comparator(&s.students[i], &s.students[j])   // 从小到大排序
}

func (s studentWrapper) Swap(i, j int) {
	s.students[i], s.students[j] = s.students[j], s.students[i]
}

func main() {
	stu1 := student{
		id:   0,
		name: "tom",
		age:  18,
	}
	stu2 := student{2,"jerry",16}
	stu3 := student{1, "mary", 20}
	students  := []student{stu1, stu2, stu3}
	s := studentWrapper{students, func(i, j *student) bool {
		return i.id < j.id
	},}
	// 使用内建的sort对三个学生实例进行排序
	sort.Sort(s)
	fmt.Println(s.students)   // [{2 jerry 16} {0 tom 18} {1 mary 20}]
}
```

> 将comparator函数抽象出来，封装一个sortStudent函数

```go
package main

import (
	"fmt"
	"sort"
)

type student struct {
	id   int
	name string
	age  int
}

type comparator func (i, j *student) bool

type studentWrapper struct {
	students []student
	comparator comparator
}


func (s studentWrapper) Len() int {
	return len(s.students)
}

func (s studentWrapper) Less(i, j int) bool {
	return s.comparator(&s.students[i], &s.students[j])   // 从小到大排序
}

func (s studentWrapper) Swap(i, j int) {
	s.students[i], s.students[j] = s.students[j], s.students[i]
}

func sortStudent(students []student, comparator comparator) {
	sort.Sort(studentWrapper{students, comparator})
}

func main() {
	stu1 := student{
		id:   0,
		name: "tom",
		age:  18,
	}
	stu2 := student{2,"jerry",16}
	stu3 := student{1, "mary", 20}
	students  := []student{stu1, stu2, stu3}

	idComparator := func(i, j *student) bool {
		return i.id < j.id
	}
	s := studentWrapper{students, idComparator}
	// 使用封装的sortStudent函数对三个学生实例进行排序
	sortStudent(students, idComparator)
	fmt.Println(s.students)   // [{0 tom 18} {1 mary 20} {2 jerry 16}]
}
```

# 5 非基于比较的排序

非基于比较的排序，与被排序的样本的实际数据状况很有关系，所以实际中并不经常使用。非基于比较的排序具有稳定性。

## 5.1 计数排序

计数排序是桶排序的一个概念的实现。所谓桶排序，将无序数组分到有限数量的桶中，然后对每个桶中的数据进行排，随后遍历每个桶，将桶中的数据拷贝到原数组中。那么计数排序是什么？

> 计数排序算法描述：
>
> 对于指定数组中元素范围的一个无序数组，比如A数组中的元素范围为0~60；
>
> 生成一个长度为61的数组B；
>
> 遍历数组A，将值出现的次数填到数组B中对应的位置，比如遍历数组A的第一个元素为2，那么在数组B的2位置上加1；第二个元素也为2，同样数组B的2位置上再加1...
>
> 遍历数组B，重塑数组A，重塑后的数组A有序。
>
> 时间复杂度为**O(N)**，额外空间复杂度为**O(N)**。
>
> 计数排序算法示意图如下：

![image-20200325220031461](C:\Users\Dabric\AppData\Roaming\Typora\typora-user-images\image-20200325220031461.png)

代码实现：

```go
// only for 0-200 value
func bucketSort(slice []int) {

	// 找到数组中的最大值
	max := 0
	for _, value := range slice {
		max = int(math.Max(float64(max), float64(value)))
	}

	// 创建一个桶
	var bucket = make([]int, max+1)

	// 遍历slice
	for i := 0; i < len(slice); i++ {
		bucket[slice[i]]++
	}

	i := 0
	for j := 0; j < len(bucket); j++ {
		for bucket[j] > 0 {
			slice[i] = j
			i++
			bucket[j]--
		}
	}
}
```

## 5.2 桶排序思想的应用

> 题目描述：
>
> 给定一个数组，求如果排序之后，相邻两数的最大差值，要求时间复杂度O(N)，且要求不能用基于比较的排序。

算法描述：

> 1、准备桶，如果数组有N个数，准备N+1个桶；
>
> 2、遍历整个数组找到`min, max`：
>
> ​	如果`min == max`，返回0；
>
> ​	如果`min != max`，`min`放到0号桶，`max`放到N号桶，中间的数等分N份，属于哪个桶，放入对应的桶中，每个桶负责的区间为`(max-min)/2`。
>
> N个数放入N+1个桶中，必定有一个桶是空的。一个桶中放入的数据个数大于等于1，所以相邻两个数之间的差值要么来自同一个桶，要么来自不同的桶。在同一个桶中的相邻两个数的差值小于区间的大小，最大的差值肯定来自于空桶相邻两个非空桶中的相邻的数。
>
> 由以上可知，相邻两数的最大差值肯定来自于两个非空桶。所以只用统计每个桶中的`min, max`，最大差值只可能来自某个非空桶的最小值减去前一个非空桶的最大值。

代码实现：

```go
package main

import (
	"fmt"
	"math"
)

func maxGap(slice []int) int {
	if slice == nil || len(slice) < 2 {
		return 0
	}

	len := len(slice)
	min := 0
	max := 0

	for _, value := range slice {
		min = int(math.Min(float64(min), float64(value)))
		max = int(math.Max(float64(min), float64(value)))
	}

	if max == min  {
		return 0
	}

	var hasNum = make([]bool, len+1)  // 桶是否为空桶
	var maxs = make([]int, len+1)   // 存每个桶中的最大值
	var mins = make([]int, len+1)	  // 存每个桶中的最小值

	bid := 0

	// 设置每个桶中的最大最小值
	for i := 0; i < len; i++ {
		// 当前数去哪个桶，哪个桶的对应的信息要改写，或者更新或者改写
		bid = bucket(slice[i], len, min, max)  // 得出数组中的每个数对应放的桶id
		if hasNum[bid] {  // false 表示不为空桶
			mins[bid] = int(math.Min(float64(mins[bid]), float64(slice[i])))
		} else {
			mins[bid] = slice[i]
		}

		if hasNum[bid] {
			maxs[bid] = int(math.Max(float64(maxs[bid]), float64(slice[i])))
		} else {
			maxs[bid] = slice[i]
		}
		hasNum[bid] = true
	}

	res := 0
	lastMax := maxs[0]
	for i := 1; i <= len; i++ {
		if hasNum[i] {
			res = int(math.Max(float64(res), float64(mins[i] - lastMax)))
			lastMax = maxs[i]
		}
	}

	return res
}

// 根据数组中的最大值最小值以及数组的长度，怎么判断一个数属于哪个桶
func bucket(num, len, min, max int) int {
	return  (num - min) * len / (max - min)
}

func main() {
	s := []int{1,3,4,5,7,10,20}
	fmt.Println(maxGap(s))

}
```

# 6 习题

## 6.1 题目一

### 用数组结构实现大小固定的队列和栈。

* 数组结构实现大小固定栈的算法描述：

> 给定数组的长度`len`为3，实现`size == 3`的栈。
>
> `index`指针指向新入栈数据的位置；
>
> 当栈为空时，`index == 0`，当栈满时，`index == size`；
>
> 压栈(push)操作：
>
> 每次数据压入`index`指向的位置，然后`index++`，如果`index == size`时报错；
>
> 弹出(pop)操作：
>
> 每次弹出`index`所指的下一个位置上的数，然后`index--`如果`index == 0`时报错；
>
> 输出栈顶(peek)操作：
>
> 每次输出`index`所指的下一个位置上的数。

代码实现：

```go
package main

import (
	"fmt"
	"math"
)

type arrayStack struct {
	arr   []int
	index int
}

func (s *arrayStack) push(value int) error {
	if s.index == len(s.arr) {
		err := fmt.Errorf("栈满了")
		return err
	}
	s.arr[s.index] = value
	s.index++
	return nil
}

func (s *arrayStack) pop() (int, error) {
	if s.index == 0 {
		err := fmt.Errorf("栈空了")
		return math.MaxInt64, err
	}
	s.index--
	return s.arr[s.index], nil
}

func (s *arrayStack) peek() int {
	if s.index == 0 {
		return math.MaxInt64
	}

	return s.arr[s.index-1 ]
}

// 工厂函数，初始化arrayStack
func initStack(initSize int) (*arrayStack, error) {

	if initSize < 0 {
		err := fmt.Errorf("栈的大小不能小于0")
		return nil, err
	}

	stack := &arrayStack{
		arr:   make([]int, initSize),
		index: 0,
	}
	return stack, nil
}
```

* 数组实现固定大小队列的算法描述：

> 给定数组长度`len`为3，实现长度为 3的队列。
>
> 三个变量`size, end, start`，三者者初始值都为0；
>
> `size`表示：队列的大小，`size == 0`队列为空，`size == 3`队列为满；
>
> `end`表示：新加一个数所指向的位置；
>
> `start`表示：取出一个数所指定的位置；
>
> 进队(push)操作：
>
> 将进队的数据放入`end`所指的位置，`end++, size++`。如果`end == len - 1`，使`end == 0`；
>
> 出队(poll)操作：
>
> 弹出`start`所指位置上的数，`start++, size--`。如果`start == len - 1`，使`end == 0`；
>
> 输出队头(peek)操作：
>
> 输出返回`start`所指位置上的数。

代码实现：

```go
type arrayQueue struct {
	arr   []int
	size  int
	end   int
	start int
}


func (q *arrayQueue) push(value int) error {
	if q.size == len(q.arr) {
		err := fmt.Errorf("队列满了")
		return err
	}

	q.size++
	q.arr[q.end] = value


	if q.end == len(q.arr) - 1 {
		q.end = 0
	} else {
		q.end++
	}
	return nil
}

func (q *arrayQueue) poll() (int, error) {
	if q.size == 0 {
		err := fmt.Errorf("栈空了")
		return math.MaxInt64, err
	}

	q.size--
	tmp := q.start
	if q.start == len(q.arr) - 1 {
		q.start = 0
	} else {
		q.start++
	}
	return q.arr[tmp], nil
}

func (q *arrayQueue) peek() int {
	if q.size == 0 {
		return math.MaxInt64
	}

	return q.arr[q.start]
}

func initQueue(initSize int) (*arrayQueue, error) {
	if initSize < 0 {
		err := fmt.Errorf("栈的大小不能小于0")
		return nil, err
	}

	queue := &arrayQueue{
		arr:   make([]int, initSize),
		size:  0,
		end:   0,
		start: 0,
	}

	return queue, nil
}
```

## 6.2 题目二

### 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈最小元素的操作。

> 要求：
>
> 1、pop、push、getMin操作的时间复杂度都是O(1)；
>
> 2、设计的栈类型使用现成的栈结构

算法描述：

> 设计两个栈结构，一个Data栈用来存储进栈的数据，Min栈用来存储Data栈中的最小值；
>
> push：
>
> 当Data栈为空时，此时push一个num，Data与Min栈同时push num；
>
> 当Data栈不为空时，此时push一个num，比较num与Min栈顶元素min的大小：
>
> ​	如果，num > min，Min栈push Min栈中的栈顶元素；
>
> ​	如果，num < min，num也push到Min栈中。
>
> pop：
>
> ​	两个栈同时pop数据。

代码实现：

```go
package main

import (
	"fmt"
	"github.com/emirpasic/gods/stacks/arraystack"
)

// 封装一个特殊栈
type specialStack struct {
	dataStack *arraystack.Stack
	minStack *arraystack.Stack
}


func (s *specialStack) push(value int) {
	if s.dataStack.Empty() {
		s.dataStack.Push(value)
		s.minStack.Push(value)
	} else {
		min, _ := s.minStack.Peek()
		if value < min.(int) {
			s.dataStack.Push(value)
			s.minStack.Push(value)
		} else {
			s.dataStack.Push(value)
			s.minStack.Push(min)
		}
	}
}

func (s *specialStack) pop() (value int) {
	v, ok := s.dataStack.Pop()
	s.minStack.Pop()
	if ok {
		value = v.(int)
	}
	return
}

func (s *specialStack) getMin() (value int) {
	v, ok := s.minStack.Peek()
	if ok {
		value = v.(int)
	}
	return
}

func main() {
	var s = specialStack{arraystack.New(), arraystack.New()}
	fmt.Println(s.getMin())
	fmt.Println(s.getMin())
	s.push(4)
	fmt.Println(s.getMin())
	s.push(5)
	fmt.Println(s.getMin())
	s.push(3)
	fmt.Println(s.getMin())
	s.pop()
	fmt.Println(s.getMin())
}
```

## 6.3 题目三

### 队列实现栈，栈实现队列

如何仅用队列结构实现栈结构？

如何仅用栈结构实现队列结构？

* 栈实现队列结构

> 栈FILO
>
> 队列FIFO
>
> 算法描述：
>
> 使用两个栈`push, pop`实现队列结构：
>
> push操作：
>
> push操作将数据都放入push栈中
>
> poll操作：
>
> 将push栈中的数据都到如到pop栈中，然后对pop栈执行pop操作
>
> peek操作：
>
> 将push栈中的数据都到如到pop栈中，然后对pop栈执行peek操作
>
> 注意两点：
>
> * push栈向pop栈中倒入数据时，必须保证push栈中的数据一次性倒完
> * pop栈中有东西，push栈一定不能往pop栈中倒入数据

代码实现：

```go
package main

import (
	"fmt"
	"github.com/emirpasic/gods/stacks/arraystack"
	"log"
)

type stackToQueue struct {
	pushStack *arraystack.Stack
	popStack *arraystack.Stack
}

func (q *stackToQueue) push(value int) {
	q.pushStack.Push(value)
}

func (q *stackToQueue) pour() {
	if q.pushStack.Empty() && q.popStack.Empty() {
		log.Fatal("The queue is empty")
	} else if q.popStack.Empty() {
		for !q.pushStack.Empty() {
			v, _ := q.pushStack.Pop()
			q.popStack.Push(v)
		}
	}
}

func (q *stackToQueue) poll() (value int) {
	q.pour()
	v, ok := q.popStack.Pop()
	if ok {
		value = v.(int)
	}
	return
}

func (q *stackToQueue) peek() (value int) {
	q.pour()
	v, ok := q.popStack.Peek()
	if ok {
		value = v.(int)
	}
	return
}

func main() {
	var queue = stackToQueue{arraystack.New(), arraystack.New()}
	queue.push(1)
	queue.push(2)
	queue.push(3)
	fmt.Println(queue.poll())
	queue.push(4)
	fmt.Println(queue.poll())

	queue.push(5)

	fmt.Println(queue.poll())
}
```

* 队列结构实现栈结构

算法描述：

> 两个队列queue help
>
> **栈push操作：**
>
> queue队列直接做push操作，向栈中添加数据
>
> **栈pop操作：**
>
> 将queue队列中除了队尾的数，其余的全部push到help队列中；
>
> pop出queue队列中的元素；
>
> 交换queue和help，在下次执行时，queue变为help，help变为queue
>
> **栈peek操作：**
>
> 将queue队列中除了队尾的数，其余的全部push到help队列中；
>
> pop出queue队列中的元素，并将该元素push到help队列中，保证原栈中的数据不变；
>
> 交换queue和help，在下次执行时，queue变为help，help变为queue
>
> **注意：**
>
> 在做pop之前，必须保证将queue队列中的所有元素push到help中

代码实现：

```go
type queueToStack struct {
	queue *stackToQueue
	help *stackToQueue
}

func (s *queueToStack) push(value int) {
	s.queue.push(value)
}

func (s *queueToStack) pop() int {
	if s.queue.isEmpty() {
		log.Fatal("stack is empty.")
	}

	for s.queue.size() != 1 {
		s.help.push(s.queue.poll())
	}

	res := s.queue.poll()
	s.swap()
	return res
}

func (s *queueToStack) peek() int {
	if s.queue.isEmpty() {
		log.Fatal("stack is empty.")
	}

	for s.queue.size() != 1 {
		s.help.push(s.queue.poll())
	}

	res := s.queue.poll()
	s.help.push(res)
	s.swap()
	return res
}

func (s *queueToStack) swap() {
	tmp := s.queue
	s.queue = s.help
	s.help = tmp
}
```

## 6.4 题目四

### 猫狗队列



宠物、狗和猫的类型如下：

## 6.5 题目五

### 转圈打印矩阵

> 【题目】给定一个整型矩阵matrix，请按照转圈的方式打印它。
>
> 例如：
>
> 1   2   3   4 
>
> 5   6   7   8 
>
> 9  10  11 12
>
> 13 14 15 16
>
> 打印结果为：
>
> 1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10
>
> 【要求】额外空间复杂度为O(1)。

## 6.10 题目十

### 打印两个有序链表的公共部分

> 【题目】给定两个有序链表的头指针head1和head2，打印两个链表的公共部分

> 算法描述：
>
> 从两个链表的头开始进行如下判断：
>
> 如果head1对应的值小于head2，head1往下移动；
>
> 如果head2对应的值小于head1，head2往下移动；
>
> 如果head1对应的值等于head2，打印该值，head1与head2共同往下移动。
>
> 类似于外排的形式。

代码实现：

```go
func printCommonPart(Node head1, Node head2) {
    for head1 != nil && head2 != nil {
        if head1.value < head1.value {
            head1 = head1.next
        } else if head1.value > head2.value {
            head2 = head2.next
        } else {
            fmt.Printf("%V ", head1.value)
            head1 = head1.next
            head2 = head2.next
        }
    }
    fmt.Println()
}
```

## 6.11 题目十一

### 判断一个链表是否为回文结构。

> 【题目】给定一个链表的头结点head，请判断该链表是否为回文结构。例如：
>
> 1 -> 2 -> 1，返回true；
>
> 1 -> 2 -> 2 -> 1，返回true；
>
> 15 -> 6 -> 15，返回true；
>
> 1 -> 2 -> 3，返回false。
>
> 进阶：如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)。

算法一描述：

> 需要O(N)的空间复杂度。
>
> 首先遍历一遍链表中的所有节点，将所有节点中的value压入栈中；
>
> 再遍历一遍链表，和弹出的栈顶相比较，如果每个都相等，返回true。

代码实现：

```go
type Node struct {
	data int
	next *Node
}

func (node *Node) isPalindromeList1() bool {
	stack := arraystack.New()
	cur := node
	for cur != nil {
		stack.Push(cur.data)
		cur = cur.next
	}

	for node != nil {
		pop, _ := stack.Pop()
		if node.data != pop.(int) {
			return false
		}
		node = node.next
	}
	return true
}
```

算法二描述：

> 需要额外空间复杂度O(n/2)
>
> 使用快慢指针：
>
> cur为快指针，起初等于head，每次走两步；
>
> right为慢指针，起初等于head.next，每次走一步。
>
> 快慢指针一起走，当快指针走完时，将慢指针走完所有链表的节点值压入栈中。
>
> 从栈顶弹出元素，看是否和从链表头开始的节点的值相等，直到栈为空为止。

代码实现：

```go
func (node *Node) isPalindromeList2() bool {
	right := node.next
	cur := node

	for cur.next != nil && cur.next.next != nil {
		right = right.next
		cur = cur.next.next
	}

	stack := arraystack.New()
	for right != nil {
		stack.Push(right.data)
		right = right.next
	}

	for !stack.Empty() {
		value, _ := stack.Pop()
		if node.data != value.(int) {
			return false
		}
		node = node.next
	}
	return true
}
```

算法三描述：

> 额外空间复杂度O(1)。
>
> 使用快慢指针fast，slow。fast每次走两步，slow一次走一步；
>
> 当fast走到链表尾部，slow走到链表中间；
>
> 从slow节点的下一个结点开始，对右部分的链表进行反转，得到一个新链表；
>
> 对比左半部分和右半部分每个节点中的值是否相等；
>
> 最后将右半部分的链表恢复原状。

代码实现：

```go
// need O(1) space
func (node *Node) isPanlindromeList3() bool {
	fast := node
	slow := node
	for fast.next != nil && fast.next.next != nil {
		fast = fast.next.next
		slow = slow.next
	}

	right := slow.next   // 右边部分的第一个节点
	slow.next = nil     // 将mid节点指向nil，构成左边部分

	pre := new(Node)
	nextNode := new(Node)
	pre = nil
	nextNode = nil
	for right != nil {
		nextNode = right.next
		right.next = pre
		pre = right
		right = nextNode
	}

	last := pre   // 保存最后一个节点
	left := node
	res := true
	for left != nil && pre != nil {
		if left.data != pre.data {
			res = false
			break
		}
		left = left.next
		pre = pre.next
	}

	// 恢复链表
	pre = nil
	//nextNode = nil
	for last != nil {
		nextNode = last.next
		last.next = pre
		pre = last
		last = nextNode
	}
	slow.next = pre
	return res
}
```

```go
// for test
func (node *Node) printSingleList() {
	for node != nil {
		fmt.Printf("%v ",node.data)
		node = node.next
	}
	fmt.Println()
}

func main() {
	head := new(Node)
	head.data = 1

	head.printSingleList()
	fmt.Println(head.isPalindromeList1())
	fmt.Println(head.isPalindromeList2())
	fmt.Println(head.isPanlindromeList3())

	fmt.Println("=====================================")

	head1 := new(Node)
	head1.data = 1

	head1.next = new(Node)
	head1.next.data = 2

	head1.printSingleList()
	fmt.Println(head1.isPalindromeList1())
	fmt.Println(head1.isPalindromeList2())
	fmt.Println(head1.isPanlindromeList3())


	fmt.Println("=====================================")

	head2 := new(Node)
	head2.data = 1

	head2.next = new(Node)
	head2.next.data = 2

	head2.next.next = new(Node)
	head2.next.next.data = 1


	head2.printSingleList()
	fmt.Println(head2.isPalindromeList1())
	fmt.Println(head2.isPalindromeList2())
	fmt.Println(head2.isPanlindromeList3())
	head2.printSingleList()

	fmt.Println("=====================================")

	head3 := new(Node)
	head3.data = 1

	head3.next = new(Node)
	head3.next.data = 2

	head3.next.next = new(Node)
	head3.next.next.data = 3

	head3.next.next.next = new(Node)
	head3.next.next.next.data = 3

	head3.next.next.next.next = new(Node)

	head3.next.next.next.next.data = 2

	head3.next.next.next.next.next = new(Node)
	head3.next.next.next.next.next.data = 1

	head3.printSingleList()
	fmt.Println(head3.isPalindromeList1())
	fmt.Println(head3.isPalindromeList2())
	fmt.Println(head3.isPanlindromeList3())
	head3.printSingleList()
}
```

## 6.12 题目十二

### 将单向链表按某值划分成左边小、中间相等、右边大的形式。

> 【题目】给定一个单向链表的头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，有部分都是值大于pivot的节点。除这个要求外，对调整后的节点顺序没有更多的要求。例如：
>
> 链表9 -> 0 -> 4 -> 5 -> 1 , pivot = 3，调整的链表可以是
>
> 1 -> 0 -> 4 -> 9 -> 5, 也可以是
>
> 0 -> 1 -> 9 -> 5 -> 4。总之，满足左部分都是小于3的节点，中间部分都是等于3的节点（本例中这个部分为空），有部分都是大于3的节点即可。对某部分内部的节点顺序不做要求。
>
> 进阶：在原问题的要求之上再增加如下两个要求。
>
> 在左、中、右三个部分的内部也做顺序要求，要求每部分里的节点从左到右的顺序与原链表中节点的先后次序一致。例如：
>
> 链表9 -> 0 -> 4 -> 5 -> 1 , pivot = 3，调整的链表是
>
> 0 -> 1 -> 9 -> 4 -> 5。在满足原问题要求的同时，左部分节点从左到右为0、1。在原链表中也是出现0，后出现1；中间部分在本例中为空，不再讨论；右部分节点从左到右为9、4、5。在原链表中也是先出现9，然后出现4，最后出现5。
>
> 如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。
>

算法描述：

> 普通的：
>
> 总体思路：借助一个存储单链表节点的数组，将链表中的节点存储到数组中，对数组中的元素进行类似快速排序的`partition`过程；经过`partition`后，将数组中的节点元素串起来，形成一个链表。步骤如下：
>
> 1. 首先，遍历链表得到链表的长度len；
> 2. 生成长度为len的数组arr；
> 3. 遍历链表的节点，将每个节点存储到arr中；
> 4. arrPartition；
> 5. 最后将arr中的节点元素串起来，返回arr中的第一个元素。

代码实现：

>```go
>package main
>
>import "fmt"
>
>type Node struct {
>   value int
>   next *Node
>}
>
>
>func listPartition1(head *Node, pivot int) *Node {
>   if head == nil {
>      return head
>   }
>
>   cur := head
>
>   var nodeArr []*Node
>
>   for cur != nil {
>      nodeArr = append(nodeArr, cur)
>      cur = cur.next
>   }
>   arrPartition(nodeArr, pivot)
>   i := 1
>   for ; i < len(nodeArr); i++ {
>      nodeArr[i-1].next = nodeArr[i]
>   }
>   nodeArr[i-1].next = nil
>   return nodeArr[0]
>}
>
>func arrPartition(nodeArr []*Node, pivot int) {
>   less := -1
>   more := len(nodeArr)
>   index := 0
>   for index != more {
>      if nodeArr[index].value < pivot {
>         swap(nodeArr, less+1, index)
>         less++
>         index++
>      } else if nodeArr[index].value == pivot {
>         index++
>      } else {
>         swap(nodeArr, more-1, index)
>         more--
>      }
>   }
>}
>
>func swap (nodeArr []*Node, x, y int) {
>   nodeArr[x], nodeArr[y] = nodeArr[y], nodeArr[x]
>}
>
>func printNodeList(head *Node) {
>   if head == nil {
>      return
>   }
>
>   for head != nil {
>      fmt.Printf("%v ->", head.value)
>      head = head.next
>   }
>   fmt.Println()
>}
>
>func main() {
>   head := new(Node)
>   head.value = 9
>   head.next = new(Node)
>   head.next.value = 0
>   head.next.next = new(Node)
>   head.next.next.value = 4
>   head.next.next.next = new(Node)
>   head.next.next.next.value = 5
>   head.next.next.next.next = new(Node)
>   head.next.next.next.next.value = 1
>   head.next.next.next.next.next = nil
>
>   printNodeList(head)
>   new_head := listPartition1(head, 3)
>   printNodeList(new_head)
>
>}
>```

进阶算法描述：

>设定三个链表，存储大于pivot的节点的链表，等于pivot的节点的链表，小于pivot的节点的链表；
>
>遍历链表，将对应的节点存放在相应的链表中；
>
>最后将三个链表串起来即可。

代码实现：

```go
func listPartition2(head *Node, pivot int) *Node {
	if head == nil {
		return head
	}

	var (
		sH *Node
		sT *Node
		eH *Node
		eT *Node
		bH *Node
		bT *Node
		next *Node  // 保存下一个节点
	)
	for head != nil {
		next = head.next
		head.next = nil
		if head.value < pivot {
			if sH == nil {
				sH = head
				sT = head
			} else {
				sT.next = head
				sT = head
			}
		} else if head.value == pivot {
			if eH == nil {
				eH = head
				sT = head
			} else {
				eT.next = head
				eT = head
			}
		} else {
			if bH == nil {
				bH = head
				bT = head
			} else {
				bT.next = head
				bT = head
			}
		}
		head = next
	}

	if sT != nil {
		sT.next = eH
		if eT != nil{
			eT = eT
		} else {
			eT = sT
		}
	}

	if eT != nil {
		eT.next = bH
	}

	if sH != nil {
		return  sH
	} else if eH != nil {
		return eH
	} else if bH != nil {
		return bH
	}
	return nil
}
```

## 6.13 题目十三

### 复制含有随机指针节点的链表。

> 一种特殊的链表节点类型：
>
> ```go
> /**
>  * Definition for a Node.
>  * type Node struct {
>  *     Val int
>  *     Next *Node
>  *     Random *Node
>  * }
>  */
> ```
>
> 
>
>  \* Definition for a Node.
>
>  \* type Node struct {
>
>  \*   Val int
>
>  \*   Next *Node
>
>  \*   Random *Node
>
>  \* }
>
>  */

普通方法：

> 使用一个map，其中map中的key存放每个节点，value存放新的节点。
>
> 1. 遍历链表，将每个节点以及每个节的副本存放在map中；
> 2. 遍历map中key对应的next指向以及rand的指向，将其赋值给value对应的next和rand指向。

代码实现：

> ```go
> type Node struct {
>    value int
>    next *Node
>    random *Node
> }
> 
> func copyListWithRand1(head *Node) *Node {
>    var nodeMap map[*Node]*Node
>    nodeMap = make(map[*Node]*Node, 2)
> 
>    cur := head
>    for cur != nil {
>       copyNode := new(Node)
>       copyNode.value = cur.value
>       nodeMap[cur] = copyNode
>       cur =  cur.next
>    }
> 
>    cur = head
>    for cur != nil {
>       nodeMap[cur].next = nodeMap[cur.next]
>       nodeMap[cur].random = nodeMap[cur.random]
>       cur = cur.next
>    }
> 
>    return nodeMap[head]
> }
> ```

进阶算法描述：

> 进阶的算法中不借助哈希表。
>
> 1. 将复制的节点连接到原先节点的后面，比如对于`1 -> 2 -> 3 -> nil`这个链表，复制完节点成为`1 -> 1' -> 2 -> 2' -> 3 -> 3' -> nil`；
> 2. 完成随机指针的复制，判断一个节点的随机指针是否为空，如果为空的话，该节点的下一个节点的随机指针也为空，否则，复制节点的随机指针为原先节点的随机指针的下一个节点；
> 3. 将链表复原，并将赋值完的链表的头节点返回。

代码实现：

```go
func copyListWithRand2(head *Node) *Node {
	cur := head

	// 将复制的节点插入原节点后面
	for cur != nil {
		next := cur.next
		copyNode := new(Node)
		copyNode.value = cur.value
		cur.next = copyNode
		copyNode.next = next
		cur = next
	}

	// 复制原节点的中random指针指向
	cur = head
	for cur != nil {
		next := cur.next.next
		curCopy := cur.next
		if cur.random != nil {
			curCopy.random = cur.random.next
		} else {
			curCopy.random = nil
		}
		cur = next
	}

	// 将链表复原
	cur = head
	res := head.next

	for cur != nil {
		next := cur.next.next
		curCopy := cur.next
		cur.next = next
		if next != nil {
			curCopy.next = next.next
		} else {
			curCopy.next = nil
		}
		cur = next
	}
	return res
}
```

## 6.14  题目十四

### 两个单链表相交的一系列问题

> 【题目】在本题中，单链表可能有环，也可能无环。给定两个单链表的头节点head1和head2，这两个链表可能相交，也可能不相交。请实现一个函数，如果两个链表相交，请返回相交的第一个节点；如果不相交，返回nil即可。
>
> 要求：如果链表1的长度为N，链表2的长度为M，时间复杂度请达到O(N+M)，额外空间复杂度请达到O(1)。

判断两个链表是否有环，如果有环返回第一个入环的节点

算法描述：

>使用哈希表，Hashset只存key。
>
>将链表中的节点存放在Hashset中；
>
>在每次存放一个节点时，判断该Hashset中是否存在该节点，如果存在返回该节点的值。

代码实现：

```go
type Node struct {
	Val int
	Next *Node
}

func getLoopNode(head *Node) *Node  {
	if head == nil {
		return nil
	}
	var nodeMap = make(map[*Node]struct{}, 10)
	cur := head
	for {
		if cur == nil {
			return nil
		}
		if !findRes(cur, nodeMap) {
			nodeMap[cur] = struct{}{}
			cur = cur.Next
		} else {
			break
		}
	}
	return cur
}

// 判断一个map中指定的键是否存在
func findRes(node *Node, nodeMap map[*Node]struct{}) bool {
	_, ok := nodeMap[node]
	if ok {
		return true
	} else {
		return false
	}
}
```

> 不使用哈希表，使用快慢指针：
>
> 首先快指针fast和慢指针slow，从链表的头节点开始，fast每次走两步，slow每次走一步；
>
> 如果fast走的过程中遇到nil，表示该链表无环；
>
> 如果fast和slow指针相遇，此时fast回到链表的头节点，然后fast和slow同时走一步，二者再次相遇为第一次入环的节点。

代码实现：

```go
func getLoopNode(head *Node) *Node {
	if head == nil {
		return nil
	}
	fast := head
	slow := head
	for {
		if fast.Next == nil || fast.Next.Next == nil  {
			return nil
		}
		fast = fast.Next.Next
		slow = slow.Next
		if fast == slow {
			break
		}
	}

	fast = head
	for fast != slow {
		fast = fast.Next
		slow = slow.Next
	}
	return fast
}
```

当判断一个链表是否有环后，我们对于问题的解决才完成了第一步。之后的问题又分为三种情况：

* 两个链表无环时是否相交
* 一个链表有环一个无环是否相交（不可能相交）
* 两个链表都有环时是否相交

判断两个链表无环时是否相交：

算法描述：

> 第一种算法：
>
> 借助哈希表。
>
> 将第一个链表的节点放入哈希表中；
>
> 遍历第二个链表，和hashset中的比较，如果第一个相等则为相交的点。

代码实现：

```go
func noLoop(head1, head2 *Node) *Node {
	if head1 == nil || head2 == nil  {
		return nil
	}
	var nodeMap = make(map[*Node]struct{}, 10)
	// 将第一个链表的节点存放在nodeMap中
	cur := head1
	for cur != nil {
		nodeMap[cur] = struct{}{}
		cur = cur.Next
	}

	// 遍历第二个链表，看是否有节点在nodeMap中
	cur = head2
	for {
		if cur == nil {
			return nil
		}
		if findRes(cur, nodeMap) {
			return cur
		} else {
			cur = cur.Next
		}
	}
}
```

> 第二种算法：
>
> 不使用哈希表。
>
> 先遍历linklist1，得到第一个链表的长度len1和尾节点 tail1；
>
> 同样对第二个链表做相同的操作，得到第二个链表的长度len2和尾节点tail2；
>
> 判断tail1和tail2是否相等：
>
> 如果不相等，则两个链表不想交；
>
> 否则，假如len1=100，len2=80，先让第一个链表的cur1指针走20步后，然后第二个链表的cur2指针和cur1一起走。二者一定会共同走到第一个相交的节点处。代码

代码实现：

```go
func noLoop(head1, head2 *Node) *Node {
	if head1 == nil || head2 == nil {
		return nil
	}

	n := 0
	cur1 := head1
	cur2 := head2
	for cur1.Next != nil {
		n++
		cur1 = cur1.Next
	}

	for cur2.Next != nil {
		n--
		cur2 = cur2.Next
	}

	if cur1 != cur2 {
		return nil
	}

	if n > 0 {
		cur1 = head1
		cur2 = head2
	} else {
		cur1 = head2
		cur2 = head1
	}

	n = int(math.Abs(float64(n)))

	for n != 0 {
		n--
		cur1 = cur1.Next
	}

	for cur1 != cur2 {
		cur1 = cur1.Next
		cur2 = cur2.Next
	}

	return cur1
}
```

判断两个都有环的链表是否相交。

算法描述：

>判断两个有环的链表是否相交存在以下情况：
>
>* 两条独立的有环链表，形如`66`，二者不相交；
>
>* 两个链表先相交然后公用一个环；
>
>* 两个链表从不同的节点入环。
>
>当`loop1==lopp2`时，为第二种情况，两个链表相交的节点等同于两个无环链表相交的情况，只不过是以loop1与loop2为tail；
>
>当`loop1!=loop2`时，可能为第一种或第三种情况：
>
>让loop1继续往下走，如果遇到loop2则为第三种情况，此时返回loop1或者loop2都可以；
>
>如果loop1往下走回到loop1还没遇到loop2则为第一种情况。

代码实现：

```go
func bothLoop(head1, loop1, head2, loop2 *Node) *Node {
	if loop1 == loop2 {
		cur1 := head1
		cur2 := head2
		n := 0

		for cur1.Next != loop1 {
			n++
			cur1 = cur1.Next
		}

		for cur2.Next != loop2 {
			n--
			cur2 = cur2.Next
		}

		if n > 0 {
			cur1 = head1
			cur2 = head2
		} else {
			cur1 = head2
			cur2 = head1
		}

		n = int(math.Abs(float64(n)))

		for n != 0 {
			n--
			cur1 = cur1.Next
		}

		for cur1 != cur2 {
			cur1 = cur1.Next
			cur2 = cur2.Next
		}
		return cur1
	} else {
		cur := loop1.Next
		for cur != loop1 {
			if cur == loop2 {
				return loop1
			}
			cur = cur.Next
		}
		return nil
	}
}
```

两个链表相交的问题解决：

```go
func getIntersectNode(head1, head2 *Node) *Node {
	if  head1 == nil || head2 == nil {
		return nil
	}

	loop1 := getLoopNode(head1)
	loop2 := getLoopNode(head2)

	if loop1 == nil && loop2 == nil {
		return noLoop(head1, head2)
	}

	if loop1 != nil && loop2 != nil {
		return bothLoop(head1, loop1, head2, loop2)
	}
	return nil
}

// for test
func main() {
	// 1->2->3->4->5->6->7->nil
	head1 := new(Node)
	head1.Val = 1
	head1.Next = new(Node)

	head1.Next.Val = 2
	head1.Next.Next = new(Node)

	head1.Next.Next.Val = 3
	head1.Next.Next.Next = new(Node)

	head1.Next.Next.Next.Val = 4
	head1.Next.Next.Next.Next = new(Node)

	head1.Next.Next.Next.Next.Val = 5
	head1.Next.Next.Next.Next.Next = new(Node)

	head1.Next.Next.Next.Next.Next.Val = 6
	head1.Next.Next.Next.Next.Next.Next = new(Node)

	head1.Next.Next.Next.Next.Next.Next.Val = 7
	head1.Next.Next.Next.Next.Next.Next.Next = nil

	// 0->9->8->6->7->null
	head2 := new(Node)
	head2.Val = 0
	head2.Next = new(Node)

	head2.Next.Val = 9
	head2.Next.Next = new(Node)

	head2.Next.Next.Val = 8
	head2.Next.Next.Next = head1.Next.Next.Next  // 8->4

	fmt.Println(getIntersectNode(head1, head2).Val)


	// 1->2->3->4->5->6->7->4...
	head1 = new(Node)
	head1.Val = 1
	head1.Next = new(Node)

	head1.Next.Val = 2
	head1.Next.Next = new(Node)

	head1.Next.Next.Val = 3
	head1.Next.Next.Next = new(Node)

	head1.Next.Next.Next.Val = 4
	head1.Next.Next.Next.Next = new(Node)

	head1.Next.Next.Next.Next.Val = 5
	head1.Next.Next.Next.Next.Next = new(Node)

	head1.Next.Next.Next.Next.Next.Val = 6
	head1.Next.Next.Next.Next.Next.Next = new(Node)

	head1.Next.Next.Next.Next.Next.Next.Val = 7
	head1.Next.Next.Next.Next.Next.Next.Next = head1.Next.Next.Next

	// 0->9->8->2...
	head2 = new(Node)
	head2.Val = 0
	head2.Next = new(Node)

	head2.Next.Val = 9
	head2.Next.Next = new(Node)

	head2.Next.Next.Val = 8
	head2.Next.Next.Next = head1.Next  // 8->2

	fmt.Println(getIntersectNode(head1, head2).Val)

	// 0->9->8->6->4->5->6...
	head2 = new(Node)
	head2.Val = 0
	head2.Next = new(Node)

	head2.Next.Val = 9
	head2.Next.Next = new(Node)

	head2.Next.Next.Val = 8
	head2.Next.Next.Next = head1.Next.Next.Next.Next.Next  // 8->6

	fmt.Println(getIntersectNode(head1, head2).Val)
}
```

# 7 二叉树

## 7.1 二叉树的遍历

实现二叉树的先序、中序、后序遍历，包括递归方式和非递归方式。

### 7.1.1 二叉树遍历的递归方式

> 算法描述
>
> 先遍历整颗树的左子树，然后遍历整颗树的右子树；
>
> 此时整颗树上的节点会被访问三次；
>
> 在第一次访问所有节点为先序遍历；
>
> 在第二次访问所有节点为中序遍历；
>
> 在第三次访问所有节点为后序遍历。

```go
func Traversal(head Node) {
    if head == nil {
        return
    }
    Traversal(head.left)
    Traversal(head.right)
}
```

![image-20200330221338587](C:\Users\Dabric\AppData\Roaming\Typora\typora-user-images\image-20200330221338587.png)

具体代码实现：

```go
package main

import "fmt"

type Node struct {
	left *Node
	right *Node
	value int
}

func preOrderRecur(head *Node) {
	if head == nil {
		return
	}
	fmt.Printf("%v ", head.value)
	preOrderRecur(head.left)
	preOrderRecur(head.right)
}
func inOrderRecur(head *Node) {
	if head == nil {
		return
	}
	inOrderRecur(head.left)
	fmt.Printf("%v ", head.value)
	inOrderRecur(head.right)
}

func posOrderRecur(head *Node) {
	if head == nil {
		return
	}
	posOrderRecur(head.left)
	posOrderRecur(head.right)
	fmt.Printf("%v ", head.value)
}

// for test
func main() {
	head := new(Node)
	head.value = 1

	head.left = new(Node)
	head.left.value = 2
	head.right = new(Node)
	head.right.value = 3

	head.left.left = new(Node)
	head.left.left.value = 4
	head.left.right = new(Node)
	head.left.right.value = 5

	head.right.left = new(Node)
	head.right.left.value = 6
	head.right.right = new(Node)
	head.right.right.value = 7

	preOrderRecur(head)
	fmt.Println()

	inOrderRecur(head)
	fmt.Println()

	posOrderRecur(head)
	fmt.Println()
}
```

### 7.1.2 二叉树遍历的非递归方式

* 先序遍历（中左右）

> 算法描述：
>
> 借助一个栈结构stack；
>
> 如果head节点不为空，将其压入到栈中；
>
> 如果栈不为空执行下面的循环：
>
> 从栈中弹出一个节点为cur，输出cur中的value；
>
> 如果cur的右孩子不为空，向栈中压入右孩子；
>
> 如果cur的左孩子不为空，向占中压入左孩子；
>
> 总体思路：当前节点在弹出时，先向栈压入其右孩子，再压入左孩子。
>
> 算法流程如下示意图：

![image-20200330231500733](C:\Users\Dabric\AppData\Roaming\Typora\typora-user-images\image-20200330231500733.png)

代码实现：

```go
func preOrderUnrecur(head *Node) {
	if head != nil {
		stack := arraystack.New()
		stack.Push(head)
		for !stack.Empty() {
			cur, _ := stack.Pop()
			fmt.Printf("%v ", cur.(*Node).value)
			if cur.(*Node).right != nil {
				stack.Push(cur.(*Node).right)
			}
			if cur.(*Node).left != nil {
				stack.Push(cur.(*Node).left)
			}
		}
	}
	fmt.Println()
}
```

* 中序遍历（左中右）

> 算法描述：
>
> 借助一个stack结构；
>
> 如果head不为空，创建一个栈结构；
>
> 如果栈不为空，或者cur节点不为空开始循环：
>
> 如果cur不为空，将cur压入栈中，cur指向其左孩子；
>
> 如果cur为空，弹出栈顶节点，输出该结点对应的值，cur指向其右孩子。
>
> 整个算法流程示意图如下：

![image-20200331003033128](C:\Users\Dabric\AppData\Roaming\Typora\typora-user-images\image-20200331003033128.png)

代码实现：

```go
func inOrderUnrecur(head *Node) {
	if head != nil {
		stack := arraystack.New()
		cur := head
		for !stack.Empty() || cur != nil {
			if cur != nil {
				stack.Push(cur)
				cur = cur.left
			} else {
				tmp, _ := stack.Pop()
				cur = tmp.(*Node)
				fmt.Printf("%v ", cur.value)
				cur = cur.right
			}
		}
	}
	fmt.Println()
}
```

* 后序遍历（左右中）

> 算法描述：
>
> 借助两个栈stack1和stack2；
>
> 首先先实现中右左的遍历；
>
> 将stack1弹出的节点压入stack2中；
>
> 最后弹出stack2中的所有元素。

代码实现：

```go
func posOrderUnrecur(head *Node) {
	if head != nil {
		s1 := arraystack.New()
		s2 := arraystack.New()
		s1.Push(head)
		for !s1.Empty() {
			cur, _ := s1.Pop()
			s2.Push(cur)
			if cur.(*Node).left != nil {
				s1.Push(cur.(*Node).left)
			}
			if cur.(*Node).right != nil {
				s1.Push(cur.(*Node).right)
			}
		}
		for !s2.Empty() {
			tmp, _ := s2.Pop()
			fmt.Printf("%v ", tmp.(*Node).value)
		}
	}
	fmt.Println()
}
```

## 7.2 二叉树中找到一个节点的后继节点

> 【题目】现有一种新的二叉树节点类型：
>
> ```go
> type Node struct {
>     value int
>     left *Node
>     right *Node
>     parent *Node
> }
> ```
>
> 该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假设有一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向自己的父节点，头结点的parent指向nil。只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。在二叉树的中序遍历的序列中，node的下一个节点叫作node的后继节点。

算法思路：

> 通过上面的可知，一个节点的后继节点，是经过中序遍历的序列后，某个节点排在当前的节点的后面，那么这个节点就为当前节点的后继节点；
>
> 中序遍历的顺序：左中右
>
> 对于给定的节点cur：
>
> 如果存在右子树，那么cur的后继节点为cur节点右子树中最左的节点；
>
> 如果不存在右子树，从当前节点往上找：
>
> ​	如果cur节点为其父节点的右孩子，继续往上找；直到找到某个节点是	其父节点的左孩子，那么cur的后继就为该某个节点的父节点。
>
> 注意：二叉树最右边的节点没有后继节点

代码实现：

```go
package main

import "fmt"

type Node struct {
	value  int
	left   *Node
	right  *Node
	parent *Node
}

func successorNode(node *Node) *Node {
	if node == nil {
		return node
	}

	if node.right != nil {
		return getLeftMost(node.right)
	} else {
		for node.parent != nil && node.parent.left != nil {
            // node.parent != nil用来保证二叉树最右节点没有后继节点
			node = node.parent
			node.parent = node.parent.parent
		}
		return node.parent
	}

}

func getLeftMost(node *Node) *Node {
	if node == nil {
		return node
	}

	for node.left != nil {
		node = node.left
	}
	return node
}

// for test
func main() {
	head := new(Node)
	head.value = 1
	head.parent = nil
	head.left = new(Node)
	head.right = new(Node)

	head.left.value = 2
	head.left.parent = head
	head.left.left = new(Node)
	head.left.right = new(Node)

	head.right.value = 3
	head.right.parent = head
	head.right.left = new(Node)
	head.right.right = new(Node)

	head.left.left.value = 4
	head.left.left.parent = head.left
	head.left.left.left = nil
	head.left.left.right = nil

	head.left.right.value = 5
	head.left.right.parent = head.left
	head.left.right.left = nil
	head.left.right.right = nil

	head.right.left.value = 6
	head.right.left.parent = head.right
	head.right.left.left = nil
	head.right.left.right = nil

	head.right.right.value = 7
	head.right.right.parent = head.right
	head.right.right.left = nil
	head.right.right.right = nil

	test := head
	fmt.Println(test.value, successorNode(test).value)

	test = head.left
	fmt.Println(test.value, successorNode(test).value)
}

```

##  7.3 二叉树的序列化和反序列化

二叉树的序列化是将二叉树的逻辑形式以字符串存放在磁盘中，相当于二叉树的持久化；反序列化是将磁盘中字符串映射成其对应的二叉树。

### 7.3.1 先序方式序列化

算法描述：

> 对于一个二叉树中的节点，使用`_`表示该节点结束，`#`代表节点为空，比如中序遍历后的二叉树的节点序列为`1, 2, 4, 5, 3, 6, 7`经过序列化后的为`1_, 2_, 4_, #_, #_, 5_, #_, #_, 3_, 6_, #_, #_, 7_, #_, #_`。

代码实现：

```go
package main

import (
	"fmt"
	"strconv"
	"strings"
)

type Node struct {
	value int
	left *Node
	right *Node
}


func serialByPre(head *Node) string {
	if head == nil {
		return "#!"
	}

	var res string
	res = strconv.Itoa(head.value) + "!"
	res += serialByPre(head.left)
	res += serialByPre(head.right)
	return res
}

func reconByPreString(preStr string) *Node {
	values := strings.Split(preStr, "!")
	if values[len(values)-1] == "" {
		values = values[:len(values)-1]
	}
	fmt.Println(values)
	return reconPreOrder(values)
} 

func reconPreOrder(values []string) *Node {
	value := values[0]
	values = append(values[:0], values[1:]...)

	fmt.Println(values)
	if value == "#" {
		return nil
	}

	head := new(Node)
	head.value, _ = strconv.Atoi(value)
	head.left = reconPreOrder(values)
	head.right = reconPreOrder(values)
	return head
}

func main() {
	head := new(Node)
	head.value = 1
	head.left = new(Node)
	head.right = new(Node)

	head.left.value = 2
	head.right.value = 3

	head.left.left = new(Node)
	head.left.left.value = 4

	head.right.right = new(Node)
	head.right.right.value = 5

	values := serialByPre(head)
	fmt.Println(serialByPre(head))
	new_head := reconByPreString(values)
}
```



### 7.3.2 按层序列化

# 字典树（前缀树）的实现

## 字典树介绍

字典树又称为前缀树，其英文名为`Trie`。`Trie`树是一种树形结构，并且是一种多叉树，其优点：

> 1. 利用字符串的公共前缀来节约存储空间
> 2. 查询每个单词的或者条目的时间复杂度和字典中一共有多少条目无关
> 3. 时间复杂度为`O(w)`，其中`w`为查询单词的长度

比如加入"abc"、"cat"、"dog"、"deer"、"panda"、"abcd"、"abd"、"bcd"、"b"之后，字典树如下图所示：

 ![image-20200420222203367](C:\Users\Dabric\AppData\Roaming\Typora\typora-user-images\image-20200420222203367.png)

## 字典树的性质

字典树的基本性质如下：

* 根节点没有字符路径。除根节点外，每一个节点都被一个字符路径找到；
* 从根节点出发到任何一个节点，如果将沿途经过的字符连接起来，一定为某个加入过的字符串的前缀；
* 每个节点向下所有的字符路径上的字符都不同。

## 字典树中的节点定义

从根节点找下一个节点之前已经知道下一个节点是什么了，或者说，从根节点搜索某一个单词，之所以能够来到这个节点，是因为从根节点就知道下一个节点是什么。所以在Trie结构中，字母应当存储在指向下一个节点的路径上，而节点中可以不存储相应的字母。

从简单的先来考虑，比如说该字典树主要实现对英文单词的查询，那么字典树中的每个节点应当有26个指向下个节点的指针；另外，由于英文中某些单词是某些单词的前缀，所以在Trie结构中应当有一个标识来标识一个单词是否结尾；增加一个功能，每个节点有一个属性代表有多少个单词公用这个节点。于是该节点的定义如下：

```go
type TrieNode struct {
	end int    // 标识一个单词的结尾
	path int   // 代表多少个单词公用这个节点
	nexts []*TrieNode
}
```

当字符种类较多的情况下，可以选择用map来实现`TrieNode`结构。map中可以存储某个char到下一个Node的关系，就可以使用这个映射到达相应的节点。

```go
type TrieNode struct {
    end int
    path int
    nexts map[byte]*TrieNode
}
```

## 字典树的实现

假设组成所有单词的字符仅是`'a'~'z'`，实现字典树结构，并包含以下四个主要功能：

> * 添加`word`，可重复添加；
> * 删除`word`，如果`word`添加过多次，仅删除一个；
> * 查询`word`是否在字典树中；
> * 返回以字符串`pre`为前缀的单词数量。

### 字典树结构的实现

```go
// 字典树节点
type TrieNode struct {
	end int
	path int
	nexts [] *TrieNode
}

// 构造字典树节点
func newTrieNode() *TrieNode {
	return &TrieNode{0,0,make([]*TrieNode, 26)}
}

// 字典树
type Trie struct {
	root *TrieNode
}

// 构造一个字典树
func newTriee() *Trie {
	return &Trie{root:newTrieNode()}
}
```

### insert实现

算法描述：

> 假设word的长度为N，从左向右依次遍历word中的每个字符，并从头结点开始根据每个字符，找到下一个节点：
>
> 如果下一个节点不存在，就建立新的节点，当前指向指向该字符对应的节点，`path++`
>
> 如果下一个节点存在，继续向下找，当前指向指向该字符对应的节点，`path++`
>
> 当word中的所有字符都添加到Trie中后，最后一个节点`end++`

代码实现：

```go
func (trie *Trie) insert(word string) {
    if len(word) == 0 {
        return
    }
    
    node := trie.root
    node.path++
    var index byte
    index = 0
    chs := []byte(word)
    
    for i := 0; i < len(chs); i++ {
        index = chs[i] - byte('a')
        if node.nexts[index] == nil {
            node.nexts[index] = newTrieNode()
        }
        node = node.nexts[index]
        node.path++
    }
    node.end++
}
```

### search实现

算法描述：

> 同样，对于给定字符串`word`，从左向右依次遍历`word`中的每个字符，并从根节点开始根据每个字符找到下一个节点：
>
> ​	如果下一个节点不存，表明这个单词没有被插入到`Trie`中，直接返回`false`；
>
> ​	如果下一个节点存在，继续往下查找；
>
> 当遍历完`word`中的所有字符时，此时判断`word`中最后一个字符对应的节点的`end`是否为`0`：
>
> ​	如果`end == 0`，返回false;
>
> ​	如果`end != 0`，返回true。

代码实现：

```go
func (trie *Trie) search(word string) bool {
    if len(word) == 0 {
        return false
    }
    node := trie.root
    chs := []byte(word)
    var index byte
    index = 0
    
    for i := 0; i < len(chs); i++ {
        index = chs[i] - byte('a')
        if node.nexts[index] == nil {
            return false
        }
        node = node.nexts[index]
    }
    return node.end != 0
}
```

### delete实现

算法描述：

> 输入`word`：
>
> 首先，调用`search`方法，看`word`是否在`Trie`树中：
>
> ​	如果不存在直接返回；
>
> ​	如果存在进行下面的流程。
>
> 从左向右依次遍历`word`中的字符，并从根节点开始根据每个字符，找到下一个节点。
>
> 在找的过程中，把遍历过的每一个结点的`path`减1，如果一个节点`path-1==0`时，直接删除当前节点后的所有路径，然后返回；
>
> 如果遍历到最后一个节点，此时最后一个节点`path--, end--`

算法实现：

```go
func (trie *Trie) delete(word string) {
    if trie.search(word) {
        node := trie.root
        chs := []byte(word)
        node.path++
        var index byte
        index = 0
        
        for i := 0; i < len(chs); i++ {
            index = chs[i] - byte('a')
            node.nexts.path--
            if node.nexts.path == 0 {
                node.nexts[index] = nil
                return
            }
            node = node.nexts[index]
        }
        node.end--
    }
}
```

### prefixNumber实现

算法描述：

> 和查找的过程相同，根据`pre`中的字符不断找到节点，找到最后的节点，直接返回该节点对应的`path`

算法实现：

```go
func (trie *Trie) prefixNumber(pre string) int {
    if len(pre) == 0 {
        return 0
    }
    
    node := trie.root
    chs := []byte(pre)
    var index byte
    index = 0
    
    for i := 0; i < len(chs); i++ {
        index = chs[i] - byte('a')
        if node.nexts.[index] == nil {
            return 0
        }
        node = node.nexts[index]
    }
    return node.path
}
```

```go
// for test
func main() {
	trie := newTrie()
	trie.insert("abc")
	trie.insert("cat")
	trie.insert("dog")
	trie.insert("deer")
	trie.insert("panda")
	trie.insert("abcd")
	trie.insert("abd")
	trie.insert("bcd")
	trie.insert("b")

	fmt.Println(trie.search("abc"))
	fmt.Println(trie.prefixNumber("abc"))
	fmt.Println(trie.prefixNumber("b"))
	trie.delete("bcd")
	fmt.Println(trie.search("b"))
	fmt.Println(trie.search("bcd"))
}

```



